% !TeX root = Proposal.tex
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US

%=============================================================================
%
% This proposal will be written as an article
%
%=============================================================================
\documentclass[11pt,a4paper,titlepage]{article}

%opening
\title{Robust optimization and parameter estimation of re-entrant lines and
    queueing networks \\ PhD Research Proposal}
\author{Harold Ship \\ University of Haifa}
%=============================================================================
%
% This part of the preamble is the package importing and setup
%
%=============================================================================


% UTF file input
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}

% math stuff
\usepackage[fleqn]{amsmath}
\usepackage{amsfonts} % for mathbb
\usepackage{mathtools} % loads amsmath plus other tools
\usepackage{fixmath} % fix greek letters
\usepackage{relsize} % for \mathlarger
\usepackage{bm}

% math theorems and theorem environments
\usepackage{amsthm}

% biblatex for references
\usepackage{csquotes} % ensures biblatex quotes things correctly
\usepackage[backend=biber,style=apa,autocite=inline]{biblatex}
\DeclareLanguageMapping{english}{english-apa}
\addbibresource{../personal_bibliography.bib}

% puts hyperlinks in PDF. Must be loaded before cleveref
\usepackage{hyperref}
\hypersetup{hypertexnames=false}

% better cross-refs like Equations, etc
\usepackage{cleveref}

% Glossary, acronym
\usepackage[acronym,toc,nonumberlist]{glossaries}
\loadglsentries{glossary}
\makeglossaries

% drawings
\usepackage{tikz}
\usetikzlibrary{positioning}% To get more advances positioning options
\usetikzlibrary{arrows}% To get more arrow heads
\usetikzlibrary{shapes.geometric}% To get more shapes
\usetikzlibrary{fit}% To fit shapes inside shapes


%=============================================================================
%
% My macros
%
%=============================================================================
\renewcommand*{\vec}[1]{\ensuremath{\bm{#1}}}%
\newcommand*{\mat}[1]{\ensuremath{\mathrm{#1}}}%
\newcommand*{\transpose}[1]{\ensuremath{#1^{\mathrm{T}}}}%
\newcommand*{\dd}{\ensuremath{\mathop{}\!\mathrm{d}}}%
\newcommand*{\dt}[1]{\ensuremath{#1^{\prime}}}%
\newcommand*{\R}{\ensuremath{\mathop{}\!\mathbb{R}}}%
\newcommand*{\RR}[1]{\ensuremath{\mathop{}\!\mathbb{R}^{#1}}}%
\newcommand*{\optimal}[1]{\ensuremath{#1^*}}%
\newcommand*{\uncertainset}[1]{\ensuremath{\mathcal{#1}}}%
\newcommand*{\defnterm}[1]{\textbf{#1}}%
% sclp math model macros
\newcommand*{\qnet}{\ensuremath{\mathcal{N}}}%
\newcommand*{\serv}{\ensuremath{i}}%
\newcommand*{\nserv}{\ensuremath{I}}%
\newcommand*{\class}{\ensuremath{j}}%
\newcommand*{\nclass}{\ensuremath{J}}%
\newcommand*{\queue}{\ensuremath{k}}%
\newcommand*{\nqueue}{\ensuremath{K}}%

% other macros
\newcommand\needc{{\color{purple}\textit{(citation needed)}}}
\newcommand\tbd{{\color{orange}\textit{TBD}}}

% math theorem environments (must be after cleveref)
\theoremstyle{definition}
\newtheorem{assumption}{Assumption}
\newcommand{\assumptionautorefname}{Assumption}
\newtheorem{example}{Example}
\newcommand{\exampleautorefname}{Example}


\begin{document}

% these styles are for tikz drawings in this section
\tikzstyle{server}=[%
rectangle,
minimum height=3cm,
%rounded corners=4pt,
text height=0.75cm,
text depth=.5cm,
text width=1cm,
inner xsep=1em,
inner ysep=1em,
text centered,
draw=black!50
]
\tikzstyle{vserver}=[%
rectangle,
rounded corners,
minimum height=3cm,
%rounded corners=4pt,
text height=0.75cm,
text depth=.5cm,
text width=1cm,
inner xsep=1em,
inner ysep=1em,
text centered,
draw=black!50,
fill=black,
fill opacity=0.1
]
\tikzstyle{buffer}=[%
rectangle,
minimum height=1cm,
%rounded corners=4pt,
text height=0.75cm,
text depth=.5cm,
text width=1cm,
text centered,
inner sep=0pt,
draw=red!50,
fill=red!20
]
\tikzstyle{input}=[%
rectangle,
minimum height=1cm,
%rounded corners=4pt,
text height=0.75cm,
text depth=.5cm,
text width=1.5cm,
text centered,
inner sep=0pt,
draw=white!0,
fill=white!0
]
\tikzstyle{output}=[%
rectangle,
minimum height=1cm,
%rounded corners=4pt,
text height=0.75cm,
text depth=.5cm,
text width=1cm,
text centered,
inner sep=0pt,
draw=white!0,
fill=white!0
]
\tikzstyle{task}=[%
rectangle,
minimum height=1cm,
%rounded corners=4pt,
text height=0.75cm,
text depth=.5cm,
text width=1cm,
text centered,
inner sep=0pt,
draw=black!50,
fill=orange!20
]
\tikzstyle{taskflow}=[%
semithick,
blue,
below,
->,
>=stealth
]


\pagenumbering{roman}

%=============================================================================
% Make the title page and other boilerplate
%=============================================================================
\maketitle \clearpage
\tableofcontents \clearpage
\iffalse % remove to enable list of figures
\listoffigures \clearpage
\fi
\iffalse % remove to enable list of tables
\listoftables \clearpage
\fi
\printglossaries \clearpage


\pagenumbering{arabic}
\setcounter{page}{1}


%=============================================================================
% Introduction
%=============================================================================
\section{Introduction}
\label{sec:introduction}

%In queueing theory,
%a re-entrant line,
%or \gls{reqn} is a queueing network where tasks can be processed by servers
%in a fixed order.
%In particular,
%the tasks can be processed by the same servers more than once.
%Each server has several buffers.
%Tasks arrive at the buffers in a predetermined order \needc.
%This is similar to \glspl{mcqn},
%in which each server has multiple buffers for processing different classes of
%tasks.
%However, the \gls{reqn} model only contains a single job class \needc.
%
%The scheduling of \gls{reqn} and \gls{mcqn} systems can be modeled and solved
%as optimization problems.
%We look at finite time horizon scheduling problems.
%We can naively model these problems as discrete tasks arriving with an arrival
%process A and a service process S.
%However,
%the resulting optimization problem is too large to solve \needc.
%In order to overcome this issue,
%we can approximate the system as a fluid flow problem,
%where the stochastic processes are replaced with \tbd{}
%under certain \tbd{} conditions.
%We can then solve the fluid flow problem using \gls{sclp} \needc,
%and apply the solution back to the original discrete network.
%
%It is often the case that the data required for optimization is known with a
%degree of uncertainty.
%In particular,
%the exogenous arrival rate and the service rate of tasks may be known only
%approximately.
%This uncertainty in these rates can arise from several sources \needc:
%\begin{itemize}
%    \item they may be difficult to measured exactly,
%    \item they may change slightly over time,
%    \item there may be changes,
%    \item it may not be possible to assign decision variables with
%        the precision of the solution,
%        causing inaccuracies to accumulate.
%\end{itemize}
%
%There are different strategies for dealing with uncertainty in
%optimization problems.
%\Gls{so} is one such strategy.
%The main idea of \gls{so} is to treat the data as random variables.
%In our case,
%this would mean the arrival rates and service rates would be treated as
%random variables.
%Usually,
%assumptions are made about the family or the distribution of these variables,
%and part of the optimization algorithm involves obtaining estimates for them.
%\Gls{so} tries to find the most likely optimal solution \needc.
%\Gls{ro} is another strategy for solving optimization problems with uncertainty
%in the data.
%In general,
%\gls{ro} uses a more conservative decision procedure than \gls{so}.
%The solution obtained,
%known as the robust solution,
%is a worst-case solution.
%This means that it is the best solution that is feasible in for all possible
%values of the data,
%where possible means within the values allowed \needc.
%The set of allowed values for the data is called the \textbf{uncertainty set}.
%
%Recently,
%there has been work on \acrlong{ro} of \gls{sclp} problems,
%in particular for \gls{mcqn}.
%The current state of the art can solve \gls{sclp} for constant data.
%However,
%there is still a lot of outstanding work.
%
%\begin{figure}
%    \centering
%    \begin{tikzpicture}[node distance=2.5cm]
%        \node[buffer] (B1) at (0,0) {$B_1$};
%        \node[buffer] (B2) [below of=B1] {$B_2$};
%        \node[buffer] (B3) [right of=B1] {$B_3$};
%        \node[buffer] (B4) [right of=B2] {$B_4$};
%        \node[input] (I1) [left of=B1] {Type 1};
%        \node[input] (I2) [left of=B2] {Type 2};
%        \node[output] (O1) [right of=B3] {};
%        \node[output] (O2) [right of=B4] {};
%        \node[server,fit=(B1) (B2)] (S1) {};
%        \node[fill=white] at (S1.north) {Server 1};
%        \node[server,fit=(B3) (B4)] (S2) {};
%        \node[fill=white] at (S2.north) {Server 2};
%        \path[taskflow] (B1) edge node {$\mu_1$} (B3);
%        \path[taskflow] (B2) edge node {$\mu_2$} (B4);
%        \path[taskflow] (I1) edge node {$\lambda$} (B1);
%        \path[taskflow] (I2) edge node {$\lambda$} (B2);
%        \path[taskflow] (B3) edge node {$\mu_3$} (O1);
%        \path[taskflow] (B4) edge node {$\mu_4$} (O2);
%    \end{tikzpicture}
%    \caption[Example queueing network with two servers.]{
%        \label{fig:queue-net}
%        Example queueing network with two servers.
%    }
%\end{figure}
%
%

%Many applications today need to run as a collection of cooperating services
%running on a set of computer servers.
%The reasons for this are many and varied.
%There are applications which require more computing power than is available on
%a single computer,
%and the most economical way to run it is to distribute the workload across
%multiple machines.
%Deep neural networks are an example,
%where training is conducted on many computers in parallel.
%In other cases,
%different functions in a complex system, or system of systems may run on
%heterogeneous computing devices.
%
%
%Workload placement problems.
%Queueing theory.
%SCLP can solve them.

New applications based on the \gls{iot} are often too large to run on a single machine.
They must be divided into separate jobs that run on multiple computing devices that live both in a Cloud system and close to the \gls{iot} devices -- on the Edge.

The efficient assignment of jobs to computing devices in cloud and edge networks is a difficult computational problem in optimization and optimal control,
known as the Workload Placement Problem.
%Furthermore,
%some of the data required to perform the optimization is often not known exactly.
Today,
the workload placement problem is usually solved one job at a time \autocite{10.1145/3391196,youssef_2020}:
a scheduler process takes one or more jobs from an input stream,
examines the state of all the servers,
decides to which server queues to place those jobs.
However,
this may not make optimal use of the servers' resources.

This document proposes research for a PhD in Statistics at University of Haifa in the area of parameter estimation for workload placement.


\example{
    \label{ex:single-computer-concrete}
    Suppose we have single computer that will be used to run jobs over the next 10 hours.
    It takes 1 minute to complete each job,
    so the computer can service 60 jobs per hour.
    Meanwhile, additional jobs arrive at a constant rate of 40 per hour.
    The computer has a queue for waiting jobs which starts with 100 jobs in it.

    If we let the computer work at $100\%$ of its capability,
    then after five hours ($100 + 40 t = 60 t \implies t = 5$) the queue will be empty.
    We can then let the computer work at $66.67\%$ for the next five hours,
    so that it processes jobs at the rate they arrive.
    In this way it will keep the queue empty.
    \Cref{fig:single-computer-concrete} illustrates this setup.

    \begin{figure}
        \centering
        \resizebox{\textwidth}{!}{
            \begin{tikzpicture}[node distance=2.5cm]
                % Server nodes
                \node[buffer,font=\tiny] (B) at (0,0) {$x(0)=100$};
                \node[fill=white, fill opacity=0.5, text opacity=1] at (B.north) {$B$};
                \node[input] (I) [left of=B] {};
                \node[output] (O) [right of=B] {};
                \node[server,fit=(B)] (S) {};
                \node[fill=white] at (S.north) {Server};
                % Network flow paths
                \path[taskflow] (I) edge node {$40$} (B);
                \path[taskflow] (B) edge node {$60$} (O);
            \end{tikzpicture}
        }% resizebox
        \caption[Single computer with constant job rate.]{
            \label{fig:single-computer-concrete}
            A single computer server with constant job arrival rate of $40$ jobs per hour.
            The computer contains a job queue $x(t)$,
            containing 100 jobs at $t=0$.
            It services the jobs at rate $60$ jobs per hour,
            after which they exit the system.
        }
    \end{figure}
}


\example{
    \label{ex:one-computer-two-classes}
    Our next example builds on \Cref{ex:single-computer-concrete}
    by adding a second job class serviced by the same computer.
    The jobs of the two classes arrive at rates $\lambda_1, \lambda_2$,
    where they enter queues $B_1, B_2$ with capacities $x_1(t), x_2(t)$
    at time $t$.
    The server can process jobs of class $j$ at rate $\mu_j$,
    for $j=1,2$.
    \Cref{fig:two-computer-one-input} illustrates this setup.

    We assign a cost per unit time to each buffer $c_1, c_2$,
    and try to minimize the objective function

    \begin{equation}
        \label{eq:two-computer-one-input-objective}
        z(t) = \int\limits_0^T
            \left( c_1 x_1(t) + c_2 x_2(t) \right) \dd{t}.
    \end{equation}

    The length of the queues $B_k, k=1,2$ depends on three things:
    jobs arriving at the queue,
    jobs being processes by the server,
    and the initial quantity at time $t=0$.
    Since we now require the computer to work on two job classes,
    we introduce the control variables $u_1(t), u_2(t)$
    which allow us to specify how much effort to apply to each job class
    at time $t$.
    The server $S_1$ has a maximum rate it can operate,
    which we can normalize to $1$.
    This gives us the following constraints.
    \Cref{eq:two-computer-one-input-server-constraints}  on the server:
    \Cref{eq:two-computer-one-input-balancing-constraints} constrains the queue lengths $x_1(t), x_2(t)$ at time $t$.

    \begin{align}
        \label{eq:two-computer-one-input-server-constraints}
        \begin{split}
            0 \leq u_1(t) & \leq 1 \\
            0 \leq u_1(t) & \leq 1 \\
            0 \leq u_1(t) + u_2(t) & \leq 1
        \end{split}
    \end{align}

    \begin{align}
        \label{eq:two-computer-one-input-balancing-constraints}
        \begin{split}
            x_1(t) & = x_1(0) - \int\limits_0^t \mu_1 u_1(t) \dd{s} + \lambda_1 t \\
            x_2(t) & = x_2(0) - \int\limits_0^t \mu_2 u_2(t) \dd{s} + \lambda_2 t
        \end{split}
    \end{align}

    \begin{figure}
        \centering
        \resizebox{\textwidth}{!}{
            \begin{tikzpicture}[node distance=1cm]
                % buffer nodes
                \node[buffer, font=\tiny] (B1) at (0,0) {$x_1(t)$};
                \node[fill=white, fill opacity=0.5, text opacity=1, font=\scriptsize] at (B1.north) {$B_1$};
                \node[buffer, font=\tiny] (B2) [below=of B1] {$x_2(t)$};
                \node[fill=white, fill opacity=0.5, text opacity=1, font=\scriptsize] at (B2.north) {$B_2$};
                % input and output nodes
                \node[input] (I1) [left=2.5cm of B1] {};
                \node[input] (I2) [left=2.5cm of B2] {};
                \node[output] (O1) [right=2.5cm of B1] {};
                \node[output] (O2) [right=2.5cm of B2] {};
                % server nodes
                \node[server,fit=(B1)(B2)] (S1) {};
                \node[fill=white, font=\scriptsize] at (S1.north) {$S_1$};
                % Network flow paths
                \path[taskflow] (I1) edge node {$\lambda_1$} (B1);
                \path[taskflow] (I2) edge node {$\lambda_2$} (B2);
                \path[taskflow] (B1) edge node {$\mu_1$} (O1);
                \path[taskflow] (B2) edge node {$\mu_2$} (O2);
            \end{tikzpicture}
        }% resizebox
        \caption[One computer with two job classes.]{
            \label{fig:two-computer-one-input}
            One computer with two job classes.
        }
    \end{figure}
}

\example{
    \label{ex:one-computer-two-classes-concrete}
    We continue to develop our example by fixing concrete values to the parameters of \Cref{ex:one-computer-two-classes}.
    We set
    $T=10$, $\lambda_1 = 40$, $\mu_1=60$, and $x_1(0) = 100$
    like \Cref{ex:single-computer-concrete}.
    We set the remaining parameters
    $\lambda_2 = 20$, $\mu_2=25$, and $x_2(0) = 100$.

    \begin{table}
        \label{tbl:one-computer-two-classes-concrete-param-values}
        \begin{tabular}{cc}
            Parameter & Value \\
            \hline
            $T$ & 10 \\
            $\lambda_1$ & 40 \\
            $\lambda_2$ & 20 \\
            $\mu_1$ & 60 \\
            $\mu_2$ & 25 \\
            $x_1(0)$ & 100 \\
            $x_2(0)$ & 100
        \end{tabular}
        \caption[Parameter values for one computer, two job classes]
        {Parameter values for one computer, two job classes}
    \end{table}
}

%\example{
%    \label{ex:example-one-computer-two-input}
%    Building on \Cref{ex:example-single-computer-concrete},
%    we extend the model to two servers $S_1, S_2$ with buffers $B_1(t), B_2(t)$, representing one cloud and one edge computer.
%    The tasks arrive at constant rate $\lambda_0$,
%    but can run on either server.
%    %    With no loss of generality,
%    %    we can let $\lambda_0 = 1$.
%    In order to model this,
%    we introduce a ``virtual server'' $S_0$ with a buffer $B_0$.
%    Being a mathematical abstraction only,
%    we set the initial quantity of this buffer $x_0(0) = 0$.
%    We will also assign a high cost to this buffer to keep it's value at $0$.
%    Our control variables will be $u_1(t), u_2(t)$ which control how much of the input goes to each server.
%    \Cref{fig:example-two-computer-one-input} illustrates this setup.
%
%    We assign a cost per unit time to each buffer $c_0, c_1, c_2$,
%    and try to minimize the objective function
%
%    \begin{equation}
%        z(t) = \int\limits_0^T
%        \left( c_0 x_0(t) + c_1 x_1(t) + c_2 x_2(t) \right) \dd{t}
%    \end{equation}
%
%    Our controls $u_1(t), u_2(t)$ ``place'' the tasks on the different computers.
%    We accomplish this by emptying the buffer $B_0$ and filling the buffers $B_1, B_2$ which have quantities $x_0(t), x_1(t), x_2(t)$ at time $t$ respectively.
%    The balancing equations of these buffers are:
%
%    \begin{align}
%        \begin{split}
%            x_0(t) & = \lambda_0 t - u_1(t)\lambda_0 - u_2(t)\lambda_0 \\
%            x_1(t) & = x_1(0) + \int\limits_0^t \lambda_0 u_1(t) \dd{s} - \mu_1 t \\
%            x_2(t) & = x_2(0) + \int\limits_0^t \lambda_0 u_2(t) \dd{s} - \mu_2 t
%        \end{split}
%    \end{align}
%
%
%    \begin{figure}
%        \centering
%        \resizebox{\textwidth}{!}{
%            \begin{tikzpicture}[node distance=1cm]
%                % buffer nodes
%                \node[buffer, font=\tiny] (B0) at (0,0) {$x_0(t)$};
%                \node[fill=white, fill opacity=0.5, text opacity=1] at (B0.north) {$B_0$};
%                \node[buffer, font=\tiny] (B1) at (3,2) {$x_1(t)$};
%                \node[fill=white, fill opacity=0.5, text opacity=1] at (B1.north) {$B_1$};
%                \node[buffer, font=\tiny] (B2) at (3,-2) {$x_2(t)$};
%                \node[fill=white, fill opacity=0.5, text opacity=1] at (B2.north) {$B_2$};
%                % input and output nodes
%                \node[input] (I0) [left=2.5cm of B0] {};
%                \node[output] (O1) [right=2.5cm of B1] {};
%                \node[output] (O2) [right=2.5cm of B2] {};
%                % server nodes
%                \node[vserver,fit=(B0)] (S0) {};
%                \node[fill=white] at (S0.north) {$S_0$};                \node[server,fit=(B1)] (S1) {};
%                \node[fill=white] at (S1.north) {$S_1$};
%                \node[server,fit=(B2)] (S2) {};
%                \node[fill=white] at (S2.north) {$S_2$};
%                %                % Network flow paths
%                \path[taskflow] (I0) edge node {$\lambda_0$} (B0);
%                \path[taskflow] (B0) edge node {$u_1(t)\lambda_0$} (B1);
%                \path[taskflow] (B0) edge node {$u_2(t)\lambda_0$} (B2);
%                \path[taskflow] (B1) edge node {$\mu_1$} (O1);
%                \path[taskflow] (B2) edge node {$\mu_2$} (O2);
%            \end{tikzpicture}
%        }% resizebox
%        \caption[Two computers with constant job rate.]{
%            \label{fig:example-two-computer-one-input}
%            A two computer network with a constant job rate.
%        }
%    \end{figure}
%}

%\example{
%    \label{ex:example-two-computer}
%    We continue extending our example.
%
%    We assign a cost per unit time to each buffer $c_0, \ldots, c_5$,
%    and try to minimize the objective function
%
%    \begin{equation}
%        z(t) = \int\limits_0^T \sum\limits_{j=0}^{5} c_j x_j(t) \dd{t}
%    \end{equation}
%
%    \begin{align}
%        \label{eq:example-two-computer}
%        \begin{split}
%            x_0(t) & = \lambda_0 t - u_{0,2}(t) - u_{0,4}(t) \\
%            x_1(t) & = x_1(0) + \lambda_1 t - \int\limits_0^s u_{1,1}(s) \mu_1 \dd{s} \\
%            x_2(t) & = x_2(0) + \int\limits_0^t \left( u_{0,2}(t) \lambda_0 - u_{1,2}(t) \mu_1 \right) \dd{s} \\
%            x_3(t) & = x_3(0) + \lambda_2 t - \int\limits_0^s u_{2,1}(s) \mu_2 \dd{s} \\
%            x_4(t) & = x_4(0) + \int\limits_0^t \left( u_{0,4}(t) \lambda_0 - u_{2,2}(t) \mu_2 \right) \dd{s}
%        \end{split}
%    \end{align}
%
%
%    \begin{figure}
%        \centering
%        \resizebox{\textwidth}{!}{
%            \begin{tikzpicture}[node distance=1cm]
%                % buffer nodes
%                \node[buffer, font=\tiny] (B0) at (0,0) {$x_{0}(t)$};
%
%                \node[buffer, font=\tiny] (B1) at (3,4) {$x_{1}(t)$};
%                \node[buffer, font=\tiny, below=.5cm of B1] (B2) {$x_{2}(t)$};
%
%                \node[buffer, font=\tiny] (B3) at (3,-4) {$x_{3}(t)$};
%                \node[buffer, font=\tiny, above=.5cm of B3] (B4) {$x_{4}(t)$};
%
%                % server nodes
%                \node[vserver,fit=(B0)] (S0) {};
%                \node[fill=white] at (S0.north) {$S_0$};
%
%                \node[server,fit=(B1) (B2)] (S1) {};
%                \node[fill=white] at (S1.north) {$S_1$};
%
%                \node[server,fit=(B3) (B4)] (S2) {};
%                \node[fill=white] at (S2.north) {$S_2$};
%
%                % input and output nodes
%                \node[input, left=2cm of B0] (I0) {};
%                \node[input, left=6cm of B1] (I1) {};
%                \node[input, left=6cm of B3] (I2) {};
%                \node[output, right=2cm of B1] (O1) {};
%                \node[output, right=2cm of B2] (O2) {};
%                \node[output, right=2cm of B3] (O3) {};
%                \node[output, right=2cm of B4] (O4) {};
%
%                %                % Network flow paths
%                \path[taskflow] (I0) edge node {$\lambda_0$} (B0);
%                \path[taskflow] (I1) edge node {$\lambda_1$} (B1);
%                \path[taskflow] (I2) edge node {$\lambda_2$} (B3);
%                \path[taskflow] (B0) edge node {$u_{0,2}(t) \lambda_0 $} (B2);
%                \path[taskflow] (B0) edge node {$u_{0,4}(t) \lambda_0 $} (B4);
%                \path[taskflow] (B1) edge node {$u_{1,1}(t) \mu_1$} (O1);
%                \path[taskflow] (B2) edge node {$u_{1,2}(t) \mu_1$} (O2);
%                \path[taskflow] (B3) edge node {$u_{2,1}(t) \mu_2$} (O3);
%                \path[taskflow] (B4) edge node {$u_{2,2}(t) \mu_2$} (O4);
%            \end{tikzpicture}
%        }% resizebox
%        \caption[Two computers with three inputs.]{
%            \label{fig:example-two-computer}
%            A two computer network with three job classes with constant job rates.
%        }
%    \end{figure}
%}

%=============================================================================
% Theory
%=============================================================================
\section{Theory}
\label{sec:theory}

\Cref{ex:one-computer-two-classes} has two classes of jobs,
arriving at rates of $\lambda_1, \lambda_2$ respectively.
These jobs arrive at two separate job queues,
which we have modeled as if they were fluids flowing at constant rates.

However, we notice that jobs in the real world arrive individually at discrete times.
We usually model this type of phenomenon as a stochastic process.
For the particular case of jobs arriving at a queue,
we often model the arrivals as a Poisson process.
Since we have two job classes,
we add to our model two Poisson processes $\mathcal{P}_1,\mathcal{P}_2$,
with parameters $\lambda_1,\lambda_2$,
to represent the exogenous job arrival processes.
We will approximate these processes with constant,
continuous flows \tbd{~source~},
which will allow us to use \gls{sclp} to find an optimal workload placement policy.

For convenience,
we number the server $i=1,\ldots,I$,
the job classes $j=1,\ldots,J$,
and the queues $k=1,\ldots,K$.
From \Cref{fig:example-two-computer},
we see that jobs can arrive at a queue from two sources:
exogenously (from outside the system) or after processing by the server.
We use the notation $s(j)=i$ to indicate that server $i$ processes jobs of class $j$.

\tbd{~sclp model}

Given an actual running system with $j=1,\ldots,J$ job classes and $k=1,\ldots,K$ queues,
we observe two things:
the actual job arrival times $a_j$ and,
the queue lengths $x_k(t_n)$ at time $t_n, n=1,\ldots,N$.
Using these,
we can perform the optimization using different strategies such as:
\begin{itemize}
    \item Stochastic optimization, which optimizes the expected value of the objective function, and requires estimating the distributions of $x(t)$, $\mu$ and $a$
    \item Robust optimization, which gives us the best value of the objective function in the worst case realizations of $x(t)$, $\mu$ and $a$,
    but requires only their bounds.
\end{itemize}

We may or may not have historical data to provide us with initial estimates.

Some questions we are considering:

\begin{enumerate}
    \item What is the best way to simultaneously optimize the workload placement and estimate the parameters, especially $\mu$?
    \item What can we do in case the job arrival processes are not Poisson processes?
\end{enumerate}


%\subsection{\acrshort{mcqn}}
%\label{subsec:theory:mcqn}
%
%Let $\qnet$ be a queueing network containing $i = 1, \ldots, I$
%servers operating over a finite time interval $[0,T]$.
%The servers process fluid which is divided into classes $j = 1, \ldots, J$,
%and fluid from class $j$ processed by one server $s(j) = i$.
%Fluid waits for processing in buffers $k = 1, \ldots, K$,
%and,
%once processed,
%flows from buffer $f(j) = k$.
%An conceptual example of fluid or task flows can be seen in \Cref{fig:task-flows}.
%Tasks entering $\qnet$ from the outside are called exogenous,
%and tasks of class $j$ arrive at one of the servers with a rate $a_j$.
%We use this constant rate to approximate the Poisson arrival process
%with parameter $a_j$.
%
%For fluid of class $j$,
%we apply a control to server $s(j)$ at time $t$
%to process fluid at rate $u_j(t)$ per unit time,
%giving us a vector of control variables $u(t) \in \RR{J}$.
%Also at time $t$,
%the amount of fluid awaiting processing in the $k$ buffers is $x_(t)$.
%
%The specification of the basic \gls{mcqn} problem is:
%\begin{align} \label{eq:mcqn}%
%    % looks like 3 columns but is 6 as & makes a right-aligned
%    % and left-aligned pair so we have 6 columns but only use the
%    % left, right, and left from the 3 pairs
%    && \max\limits_{u(t), x(t)} &&& \int\limits_0^T(\gamma^\top +
%      (T-t)c^\top)u(t)+d^\top x(t)\mathrm{d}t \nonumber \\
%    & \mbox{MCQN} & \mbox{s.t} &&& \int\limits_0^T G u(s)\mathrm{d}s +
%      F x(t) = \alpha+at, \\
%%      x(t)   \leq \alpha+at, \\
%    &&&&& H u(t) \leq b, \nonumber \\
%    &&&&& x(t), u(t) \geq 0, ~ 0 \leq t \leq T, \nonumber
%\end{align}
%
%
%$\gamma \in \RR{J}$ is processing cost per job class,
%$c$ is \tbd.
%$d \in \RR{K}$ is the holding cost per buffer,
%$\alpha \in \RR{K}$ is the initial amount of fluid in the buffers
%$b \in \RR{I}$ is the maximum processing rate of the $J$ servers.
%Additionally,
%we have the matrices $G \in \RR{J \times K}$ and $H \in \RR{I \times J}$.
%$G$ describes the inflows $(1)$ and outflows ($p_{j,k}$).
%$F$ describes which buffers belong to which server,
%while $H$ describes the service times $\tau_j$ for each job class,
%the reciprocals of the maximum service rates $\mu_j$.
%
%\begin{align}
%    G = G_{j,k} = &
%    \begin{cases}
%        1 & f(j) = k \\
%        -p_{j,k} & f(j) \neq k
%    \end{cases} \\
%    H = H_{i,j} = &
%\begin{cases}
%    1/\mu_j & s(j) = i \\
%    0 & s(j) \neq i
%\end{cases}
%\end{align}
%
%\begin{figure}
%    \centering
%    \begin{tikzpicture}
%        \node[task] (T1) at (0,0) {$T_1$};
%        \node[task] (T2) [below left=of T1] {$T_2$};
%        \node[task] (T3) [below right=of T1] {$T_3$};
%        \node[task] (T4) [below=of T3] {$T_4$};
%        \node[task] (T5) [below left=of T4] {$T_5$};
%        \path[taskflow] (T1) edge node {} (T2);
%        \path[taskflow] (T2) edge node {} (T5);
%        \path[taskflow] (T1) edge node {} (T3);
%        \path[taskflow] (T3) edge node {} (T4.north);
%        \path[taskflow] (T4.south) edge node {} (T5.north);
%    \end{tikzpicture}
%    \caption[Example fluid or task flows.]{
%        \label{fig:task-flows}
%        Example fluid or task flows.
%        A flow is the set of arrows coming out of a task node.
%        Task $T_1$ flows to $T_2$ and $T_3$.
%        Task $T_2$ flows straight to $T_5$.
%        Task $T_3$ flows to $T_4$,
%        which then flows to $T_5$ as well.
%    }
%\end{figure}
%

%=============================================================================
% Workload Placement Example
%=============================================================================
%\subsection{Workload Placement Example}
%\label{subseq:theory:workload-placement}
%
%Suppose we have a computerized workload that we would like to run on a set of $I$ networked servers.
%The workload we wish to run is made up of several software tasks,
%divided into $J$ classes.
%We assume that tasks of class $j$ arrive according to
%a homogeneous Poisson process with parameter $a_j$.
%Each server can process any class of task,
%but is limited to $R_i$ RAM and can process at a maximum of $P_i$ operation per unit time.
%
%Tasks in class $j$ require $r_j$ RAM and have a time to live,
%which is distributed exponentially with parameter $\tau_j$.
%Equivalently, the tasks' service rate has a Poisson distribution with parameter $\mu_j = 1/\tau_j$.
%There are $K = I \times J$ buffers for tasks of class $J$ in server $I$.
%
%The number of tasks of class $j$ waiting in the buffer on server $i$ at time $t$ is $x_{i,j}(t)$,
%with initial value $x_{i,j}(0)$.
%The cpu usage of tasks of class $j$ on server $i$ at time $t$ is $u_{i,j}(t)$.
%For each task of class $j$, $y_{i,j}(t)$ indicates whether it is running on server $i$ at time $t$.
%
%We derive the following math model for the workload placement problem:
%
%\begin{align}%
%     looks like 3 columns but is 6 as & makes a right-aligned
%     and left-aligned pair so we have 6 columns but only use the
%     left, right, and left from the 3 pairs
%    && \min\limits_{u} &&& \sum\limits_i \sum\limits_j
%    \int\limits_0^T x_{i,j}(t) \mathrm{d}t \nonumber \\
%    && \mbox{s.t} &&&
%    \sum\limits_i x_{i,j}(t) = \sum\limits_i x_{i,j}(0) + a_j t -
%    \sum\limits_i {\mu_j}  \int\limits_0^t u_{i,j}(s) \textrm{d}s
%    \label{eq:workload-placement} \\
%    &&&&& \sum\limits_j y_{i,j}(t) r_j + \sum\limits_j u_{i,j}(t) r^\prime_j \leq R_i, \nonumber \\
%    &&&&& \sum\limits_j u_{i,j}(t) \leq P_i, \nonumber \\
%    &&&&& u(t), x(t) \geq 0, ~ 0 \leq t \leq T. \nonumber
%\end{align}%
%
%The model of \Cref{eq:workload-placement} is not directly computable with \gls{sclp}.
%We translate \Cref{eq:workload-placement} to the form of \Cref{eq:mcqn},
%which will enable us to use an implementation of \gls{sclp} to solve it.
%
%First,
%we compute the matrix $H$ which has dimensions $I \times K$
%and is used for the CPU and RAM constraints.
%$H$ has $I$ rows,
%one for each server,
%and has a $1$ repeated $J$ times,
%in position for that server and $0$ elsewhere.
%For example,
%the first $J$ entries of the first row have value $1$ followed by $0$'s,
%while the second row begins with $J$ $0$'s,
%followed by $J$ $1$'s,
%and continuing with $0$'s till the end.
%
%Next, we compute $F$ which has $J$ rows,
%one for each class,
%and $K-J$ columns.
%$F$ relate the buffers to the servers.
%The pattern for $F$ is to have the row $j$ of the form:
%$(0 \ldots 1 \dots 0)$,
%with the $1$ in the $j^{\text{th}}$ position repeated $I-1$ times,
%for a total of $J(I-1)=K-J$ columns.
%The reason why $F$ has only $K-J$ columns and not $K$,
%is to convert the buffer constraints to inequalities because our current implementation does not support equality constraints at this time.
%
%Next, we compute $G$,
%which represents the task flows between buffers.
%The matrix $G$ has dimension $J \times K$,
%and the entry $G_{j,k}$ has value $0$ except when $k mod J == j$.
%In this case $G_{j,k} = -\mu_x$, where $x= \lceil{k/j}\rceil$.
%
%\tbd{} Robust MCQN
%
%\tbd{} Re-entrant
%
%\tbd{} Robust re-entrant

%=============================================================================
% Questions
%=============================================================================
%\section{Questions}
%\label{sec:questions}
%
%We would like to known the bounds of the arrival and service rates.
%If there is historical data,
%what is the state of the art on these estimates?
%
%\begin{enumerate}
%    \item How can we estimate the parameters and the uncertainty set with and
%    without historical data?
%    How can we compute the robust counterpart of \gls{sclp} from this?
%    How can we create a policy for parameter estimation that doesn't lose too
%    much in terms of the objective?
%    It may be possible to estimate the data by running a system which is far
%    from optimal.
%    In many cases this could be expensive.
%    \item Can we develop a system and method to generate policies from online
%    networks that can detect changes in the data and self-adjust?
%    \item Can we extend \gls{sclp} to piecewise constant parameters,
%    in particular the task arrival rates?
%    \item What other ways can we extend the arrival process?
%    \item How can we estimate the uncertainty set for the robust problem?
%\end{enumerate}

\clearpage
\printbibliography
\label{sec:bibliography}

\end{document}
